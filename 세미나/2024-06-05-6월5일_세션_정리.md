---
title : "6월 5일 세션 정리"
date : 2024-06-05 20:35:00 +09:00
categories : [Recruiting, Interview]
tags : [Interview]
math : true
---

## 1. 인덱스

### 1.1 인덱스란 무엇인가

- 특정 조건을 만족하는 튜플(데이터)을 빠르게 조회하기 위해 혹은 빠르게 정렬(Order By) 하거나 그룹핑(Group By) 하기 위해 사용한다.
- 전체 테이블 스캔 검색의 필요성을 줄임으로써 데이터 검색 프로세스를 가속화한다.

#### 1.1.1 B+ tree

- 대부분의 RDBMS의 경우 Tree 구조의 인덱스 사용
- Tree 구조의 평균적인 시간 복잡도는 OlogN
- 다만 한 쪽으로 치우치는 트리가 발생할 수 있음. O(N)
- 이를 해결하기 위해 균형을 유지할 수 있는 B-Tree 사용
- B+ tree의 경우 리프노드의 연결로 범위 검색 작업에 효율적

#### 1.1.2 이진 탐색



### 1.2 Index를 만드는 두 가지 방법

![image-20240611173744277](./../../blog_img/2024-06-03-6월5일_세션_정리/image-20240611173744277.png)

첫번째는 PK를 써서 조회, 두번째는 PK가 아닌 것을 써서 조회하는 것이 다르다. 

#### 1.2.1 Clustered Index

- 테이블당 1개 씩만 허용된다.
- PK 설정 시 그 컬럼은 자동으로 클러스터드 인덱스가 만들어진다.
- 30% 이내에서 사용해야 좋은 선택도를 가진다.
- 인덱스 자체의 리프 페이지가 곧 데이터이다.
- MySQL에서는 PK를 설정하지 않으면 테이블 내의 Unique 제한이 걸려있는 컬럼을 찾아서 그걸 기준으로 PK로 자동으로 설정한다. 근데 Unique한 값도 없으면 임의의 값, 컬럼을 MySQL에서 만들어서 보이지 않지만 그걸 가지고 관리한다.

<img src="./../../blog_img/2024-06-03-6월5일_세션_정리/image-20240611174537942.png" alt="image-20240611174537942" style="zoom: 80%;" />

#### 1.2.2 Non Clustered Index

- 테이블 당 약 240개의 인덱스를 생성 가능
- 인덱스 자체의 리프 페이지는 데이터가 아닌 데이터가 위치하는 포인터이다.
- 3% 이내에서 사용해야 좋은 선택도를 가진다.

<img src="./../../blog_img/2024-06-03-6월5일_세션_정리/image-20240611174548023.png" alt="image-20240611174548023" style="zoom: 80%;" />

### 1.3 Optimizer

- 쿼리에 대한 최적의 실행 계획 수립
- Order By 처리
- 기본 데이터 처리(풀테이블 스캔, 인덱스 스캔)
- 테이블의 레코드 건수가 너무 작은 경우
- 인덱스를 레인지 스캔을 할 수 있어도 조건에 일치하는 레코드가 많은 경우

> Select 앞에 Explain을 붙여서 쿼리하면 쿼리 실행 계획을 볼 수 있다.

### 1.4 무조건 많은 인덱스가 좋은가

인덱스 하나당 B+트리 하나가 생성되는 것이기 때문에 성능 문제가 생길 수도 있다. 왜냐하면 트리 구조에 데이터를 삽입할 때 정렬이 일어날 수 있고 재배치(?)가 일어날 수 있는데 한 번의 삽입으로 여러 트리에 그런 작업이 일어나게 되면 디비에 데이터가 많으면 많을수록 많은 작업이 일어나기 때문이다.

## 2. 트랜잭션

### 2.1 키워드

- ACID
- redo Log
- undo Log
- Isolation Level

### 2.2 트랜잭션의 특성(ACID)

- 하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합
- Atomic(원자성)
- Consistency(일관성)
- Isolation(독립성)
- Durability(지속성)

#### 2.2.1 Atomic

- 하나의 작업 단위인 트랜잭션 안에서 수행되는 실행은 모두 완료되거나, 실패시 rollback되어 이전으로 돌아가야 한다.
- all or nothing
- rollback or undo 세그먼트를 통한 기록을 기준으로 rollback

#### 2.2.2 Consistency

- 고립된 트랜잭션의 수행이 데이터베이스의 일관성을 보존해야 한다.
- 성공적으로 수행된 트랜잭션은 정당한 데이터들만을 데이터베이스에 반영해야 한다.
- 기본 키, 외래 키 제약과 같은 명시적인 무결성 제약 조건

#### 2.2.3 Isolation

- 여러 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션의 수행에 영향받지 않고 독립적으로 수행되어야 한다.

![image-20240611182045014](./../../blog_img/2024-06-03-6월5일_세션_정리/image-20240611182045014.png)

#### 2.2.4 MVCC(Multi-Version-Concurrency-Control)

- 다중 버전 동시성 제어라는 의미로 읽기 상황에서 하나의 레코드에 대해 여러 개의 버전을 관리함으로써 락을 사용하지 않고 읽기에 대한 일관성을 제공
- 각 사용자는 특정 시점을 기준으로 가장 최근에 commit 된 데이터를 읽어 데이터의 일관성을 유지할 수 있음 (Undo log)
- 이때의 특정 시점이란 해당 트랜잭션의 격리수준(Isolation level)에 따름
- MySQL의 경우 기본적으로 Repeatable Read 수준의 격리 레벨을 제공해서 팬텀리드, non 리피터블 리드 등을 방지할 수 있음

#### 2.2.5 팬텀리드

- 한 트랜잭션이 같은 조건으로 데이터를 반복해서 읽을 때 다른 트랜잭션이 데이터를 추가해 처음에는 없던 데이터가 추가되어 반환되는 현상

#### 2.2.6 더티리드

- 한 트랜잭션이 다른 트랜잭션에서 커밋되지 않은 삽입 데이터 혹은 수정한 데이터를 읽었는데

#### 2.2.7 Non-Repeatable Read

- 한 트랜잭션에서 같은 데이터를 반복해서 읽을 때 다른 트랜잭션의 영향을 받아 다른 결과가 나오는 경우

#### 2.2.8 Durability

- 트랜잭션이 성공적으로 완료되어 커밋되고 나면, 해당 트랜잭션에 의한 모든 변경은 시스템 장애 또는 전원 손실과 같은 예상치 못한 상황이 발생하더라도 보존되어야 한다.
- 쉽게 말해 HDD, SSD 등에 저장하는 것을 말한다.
- 장애가 발생했을 경우 redo log 를 통해 복구가 가능하다.
- 그 외의 장애 상황에 대해서도 RDBMS 자체적으로 복구 로직을 가지고 있다.

