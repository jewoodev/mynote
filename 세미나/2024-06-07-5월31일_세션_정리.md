---
title : "5월 31일 세션 정리"
date : 2024-05-07 16:48:00 +09:00
categories : [Recruiting, Interview]
tags : [Interview]
math : true
---

## 1. 쿠키 vs 세션

HTTP 프로토콜 자체가 Stateless 해서 권한이 필요한 요청마다 로그인을 해야 하는데 이런 불편함을 해소하기 위해서 쿠키라는 개념이 생겨났다. 서버에서는 사용자 요청에 대해서 특정한 쿠키값을 생성해서 로그인을 했는지 여부나 로그인에 관련된 정보를 담아서 클라이언트에 내려주면 클라이언트는 그 쿠키를 활용하면서 쿠키가 만료되기 전까지는 계속해서 로그인을 재시도하지 않고 서비스를 이용할 수 있는  방식을 활용하기 위해 쓴다. 그런데 중요한 점은 쿠키를 저장하는 위치가 **브라우저**라는 점이다. 그렇기 때문에 보안적으로 취약하기 때문에 최근에는 쿠키를 이용해서 인증/인가를 구현하는 경우는 드물고, 사용자의 방문 내역, 방문한 사이트 이력, 이런 걸 주로 저장하여 맞춤 광고를 제공하는데 많이 사용된다. 쿠키는 HTTP의 Stateless 한 특성 때문에 쿠키라는게 나오게 됐다, 라는 게 포인트인 것 같다.

세션은 쿠키의 단점을 보완하기 위해 사용하는데, 쿠키와는 다르게 서버 측에 클라이언트의 상태값을 저장하고 관리하는 방식이다. 쿠키의 문제점을 먼저 알아보면, 쿠키는 탈취되었을 때 가장 위험하다. 만일, 사용자가 공유 PC에서 로그인한 상태에서 화장실을 갔을 때, 다른 사람이 로그인되어 있는 해당 PC를 이용해 쿠키를 탈취하면 쿠키 정보를 가져다가 다른 곳에서도 쓸 수 있다. 다른 곳에서도 쓸 수 있다는 점이 위험한 점이고, 그 안에 로그인한 이력과 패스워드가 담겨있으면 쿠키를 탈취한 다른 사용자가 로그인을 시도할 수 있다. 탈취에 위험에 따라서 보안적으로 불안정하다. 그리고 쿠키의 특징으로 인한 불편함이 있는데, 쿠키는 주로 브라우저 단위로 생성이 되기 때문에 브라우저마다 로그인을 따로 해야 한다. 이것은 그렇게 중요하진 않고 탈취 위험이 제일 큰 문제다. 

세션은 그래서 서버측에 로그인한 유저의 정보와 이력들을 세션이란 곳에 저장하고 관리하는 방식이다. 세션은 JSESSIONID라는 걸 발급해서 쿠키에 담아서 클라이언트에게 내려준다. 클라이언트는 JSESSIONID가 담긴 쿠키를 관리하면서 로그인이 필요한 요청에 JSESSIONID가 담긴 쿠키로 요청을 보낸다. 그렇게 됐을 때 서버에서는 JSESSIONID를 통해서 세션저장소에 이 유저가 로그인을 한 번 했던 기록이 있으면 그 기록을 저장하고 JSESSIONID를 발급하기 때문에, 동일한 JSESSIONID가 서버 세션에 이미 있다. 원래는 SESSIONID를 통해서 DB를 갔다오거나 유저 정보를 조회해야 하는데 세션저장소에 유저 정보를 저장해놓으면 DB까지 조회할 필요가 없어서 성능적으로 이점을 가진다. 

### 1.1 세션을 사용하면 무조건 좋은건지, 어떤 문제점이 있는지?

이런 세션 방식도 문제점이 있긴 하다. 어찌됐든 JSESSIONID는 유의미한 유저 정보를 갖고 있지 않긴 하지만, 탈취되면 다른 사용자가 로그인을 시도할 수 있기 때문에 탈취 위험을 피하지 못한다. 또 서버에서 세션저장소에서 세션을 관리하기 때문에 사용에 따라 많은 요청에 대해서 부하가 발생할 수 있다. 부하가 심하면 서버 인스턴스를 늘리면 되는 것 아닌가 생각할 수도 있지만, 서버 인스턴스마다 갖는 세션저장소가 인스턴스처럼 따로 존재하기 때문에 이를 로드밸런서 내부적으로 갖고 있는 알고리즘에 의해서 로드밸런싱이 될 때 한 번 로그인된 유저의 요청이 로그인을 했던 인스턴스로 항상 보내진다고 확답을 할 수 없다. 이 문제를 해결하기 위해 가장 기본적인 접근 방법으로의 해결은 Sticky Session 을 사용하는 것이다. 

[관련 문서](https://chatgpt.com/c/69b3f97b-2059-4a97-914e-fa2e7f3c4fae)

이는 로드 밸런서 설정에서 session affinity 를 활성화해서 클라이언트의 IP나 쿠키를 기반으로 특정 사용자의 요청을 동일한 서버로 라우팅하는 방법이다. 

## 2. Java의 동시성 제어

[관련 페이지](https://chatgpt.com/c/dda8cb29-1d91-4255-9354-db48dfebcc7a)

Java의 동시성 제어는 여러 스레드가 공유 자원에 안전하게 접근할 수 있도록 하기 위한 방법들을 포함합니다. 기본적으로 synchronized 키워드를 사용하여 메서드나 블록 단위로 락을 걸 수 있고, volatile 키워드를 통해 변수의 가시성을 보장할 수 있습니다. 더 나아가 ReentrantLock과 같은 락 클래스나 CountDownLatch, Semaphore와 같은 동시성 유틸리티를 사용할 수 있습니다. 또한, Executor Framework를 사용하여 스레드 풀을 관리하고, ConcurrentHashMap과 같은 동시성 컬렉션을 사용하여 보다 안전하게 데이터에 접근할 수 있습니다. 예를 들어, 이전 프로젝트에서 다수의 스레드가 동시에 데이터를 처리할 때 ConcurrentHashMap을 사용하여 성능과 안전성을 모두 확보한 경험이 있습니다.

- 꼬리 질문 : 그런데 Java로 제어할 수 없는 동시성 문제가 있습니다. 그런 문제는 어떤 문제인지 설명해주세요.

  그런 문제는 분산 시스템에서 여러 인스턴스가 동일한 데이터에 접근하는 경우에 생기는데, 서버 인스턴스 하나에서도 이런 상황은 생길 수가 있습니다. 메소드에 트랜잭션 어노테이션을 사용하면 그 메서드가 속해 있는 클래스이 프록시 객체가 만들어지기 때문인데요, 따라서 그런 상황에서는 분산락이나 데이터베이스 레벨의 동시성 제어가 필요합니다. 

- 꼬리 질문 : 근데 락을 쓰면 성능 저하가 온다고 설명해주셨는데, 그럼 안써야 되는 거 아닌가요?

  성능과 락은 트레이드오프 관계에 놓여져 있습니다. 만약에 은행 계좌 시스템에서 여러 스레드가 동시에 입출금 작업을 수행해서 데이터의 불일치가 발생한다면 시스템에서 매우 중요한 신뢰성을 잃게됩니다. 이런 경우에는 성능 저하를 감수하고서라도 락을 사용해서 데이터의 정확성을 보장하는 것이 더 중요합니다. 

  따라서 락을 사용할 때는 락의 범위를 최소화하고, AtomicInteger과 같은 원자적 변수를 활용하는 등의 전략을 사용해 성능과 안정성 사이의 균형을 맞추는 것이 중요합니다.